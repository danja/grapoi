<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>Grapoi.js - Documentation</title>
    
    
    
    
    
    <meta property="og:title" content=""/>
    <meta property="og:type" content="website"/>
    <meta property="og:image" content=""/>
    
    <meta property="og:url" content=""/>
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav class="wrap">
    
    
    <h2><a href="index.html">Home</a></h2><h2><a href="Grapoi.html" target="_blank" class="menu-item" id="grapoi_link" >Grapoi API</a></h2><h3>Classes</h3><ul><li><a href="Grapoi.html">Grapoi</a><ul class='methods'><li data-type='method'><a href="Grapoi.html#addIn">addIn</a></li><li data-type='method'><a href="Grapoi.html#addList">addList</a></li><li data-type='method'><a href="Grapoi.html#addOut">addOut</a></li><li data-type='method'><a href="Grapoi.html#base">base</a></li><li data-type='method'><a href="Grapoi.html#best">best</a></li><li data-type='method'><a href="Grapoi.html#clone">clone</a></li><li data-type='method'><a href="Grapoi.html#deleteIn">deleteIn</a></li><li data-type='method'><a href="Grapoi.html#deleteList">deleteList</a></li><li data-type='method'><a href="Grapoi.html#deleteOut">deleteOut</a></li><li data-type='method'><a href="Grapoi.html#distinct">distinct</a></li><li data-type='method'><a href="Grapoi.html#execute">execute</a></li><li data-type='method'><a href="Grapoi.html#executeAll">executeAll</a></li><li data-type='method'><a href="Grapoi.html#filter">filter</a></li><li data-type='method'><a href="Grapoi.html#hasIn">hasIn</a></li><li data-type='method'><a href="Grapoi.html#hasOut">hasOut</a></li><li data-type='method'><a href="Grapoi.html#in">in</a></li><li data-type='method'><a href="Grapoi.html#isAny">isAny</a></li><li data-type='method'><a href="Grapoi.html#isList">isList</a></li><li data-type='method'><a href="Grapoi.html#list">list</a></li><li data-type='method'><a href="Grapoi.html#map">map</a></li><li data-type='method'><a href="Grapoi.html#node">node</a></li><li data-type='method'><a href="Grapoi.html#out">out</a></li><li data-type='method'><a href="Grapoi.html#quads">quads</a></li><li data-type='method'><a href="Grapoi.html#rebase">rebase</a></li><li data-type='method'><a href="Grapoi.html#replace">replace</a></li><li data-type='method'><a href="Grapoi.html#score">score</a></li><li data-type='method'><a href="Grapoi.html#trim">trim</a></li></ul></li><li><a href="PathList.html">PathList</a><ul class='methods'><li data-type='method'><a href="PathList.html#addIn">addIn</a></li><li data-type='method'><a href="PathList.html#addList">addList</a></li><li data-type='method'><a href="PathList.html#addOut">addOut</a></li><li data-type='method'><a href="PathList.html#clone">clone</a></li><li data-type='method'><a href="PathList.html#deleteIn">deleteIn</a></li><li data-type='method'><a href="PathList.html#deleteList">deleteList</a></li><li data-type='method'><a href="PathList.html#deleteOut">deleteOut</a></li><li data-type='method'><a href="PathList.html#distinct">distinct</a></li><li data-type='method'><a href="PathList.html#execute">execute</a></li><li data-type='method'><a href="PathList.html#executeAll">executeAll</a></li><li data-type='method'><a href="PathList.html#filter">filter</a></li><li data-type='method'><a href="PathList.html#hasIn">hasIn</a></li><li data-type='method'><a href="PathList.html#hasOut">hasOut</a></li><li data-type='method'><a href="PathList.html#in">in</a></li><li data-type='method'><a href="PathList.html#isAny">isAny</a></li><li data-type='method'><a href="PathList.html#isList">isList</a></li><li data-type='method'><a href="PathList.html#list">list</a></li><li data-type='method'><a href="PathList.html#map">map</a></li><li data-type='method'><a href="PathList.html#node">node</a></li><li data-type='method'><a href="PathList.html#out">out</a></li><li data-type='method'><a href="PathList.html#quads">quads</a></li><li data-type='method'><a href="PathList.html#trim">trim</a></li></ul></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">Grapoi.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { baseDataset, baseTerm } from './lib/base.js'
import { rebaseDataset } from './lib/rebase.js'
import { replaceDataset } from './lib/replace.js'
import sortByScore from './lib/sortByScore.js'
import toPathArray from './lib/toPathArray.js'
import toTerm from './lib/toTerm.js'
import toTermArray from './lib/toTermArray.js'
import Path from './Path.js'
import PathList from './PathList.js'

/**
 * Class representing a graph pointer
 * @extends PathList
 */
class Grapoi extends PathList {
  /**
   * Create a new instance
   * @param {DatasetCore} dataset Dataset for the pointers
   * @param {Environment} factory Factory for new quads
   * @param {Path[]} ptrs Use existing pointers
   * @param {Term} term Term for the pointers
   * @param {Term[]} terms Terms for the pointers
   * @param {Term} graph Graph for the pointers
   * @param {Term[]} graphs Graphs for graph pointers
   * @example
   * example here
   */
  constructor({ dataset, factory, ptrs, term, terms, graph, graphs }) {
    if (term || terms) {
      terms = terms || term
    }

    if (graph || graphs) {
      graphs = graphs || graph
    }

    if (!ptrs &amp;&amp; terms) {
      ptrs = toPathArray(terms, { dataset, factory, graph: graphs })
    }

    super({ dataset, factory, ptrs, graphs })
  }

  _toTerm(value) {
    return toTerm(value, { factory: this.factory })
  }

  _toTermArray(values) {
    return toTermArray(values, { factory: this.factory })
  }

  /**
   * Add quad(s) with the current terms as the object
   * @param {Grapoi|Grapoi[]|Term|Term[]} predicates Predicates of the quads
   * @param {Grapoi|Grapoi[]|Term|Term[]} [subjects] Subjects of the quads
   * @param {function} [callback] Function called for each subject as a pointer argument
   * @returns {Grapoi} this
   */
  addIn(predicates, subjects, callback) {
    if (typeof subjects === 'function') {
      callback = subjects
      subjects = null
    }

    if (!subjects) {
      subjects = [this.factory.blankNode()]
    }

    return super.addIn(this._toTermArray(predicates), this._toTermArray(subjects), callback)
  }

  /**
   * Add list(s) with the given items
   * @param {Grapoi|Grapoi[]|Term|Term[]} predicates Predicates of the lists
   * @param {Grapoi|Grapoi[]|Term|Term[]} [items] List items
   * @returns {Grapoi} this
   */
  addList(predicates, items) {
    return super.addList(this._toTermArray(predicates), this._toTermArray(items))
  }

  /**
   * Add quad(s) with the current terms as the subject
   * @param {Grapoi|Grapoi[]|Term|Term[]} predicates Predicates of the quads
   * @param {Grapoi|Grapoi[]|Term|Term[]} [objects] Objects of the quads
   * @param {function} [callback] Function called for each subject as a pointer argument
   * @returns {Grapoi} this
   */
  addOut(predicates, objects, callback) {
    if (typeof objects === 'function') {
      callback = objects
      objects = null
    }

    if (!objects) {
      objects = [this.factory.blankNode()]
    }

    return super.addOut(this._toTermArray(predicates), this._toTermArray(objects), callback)
  }

  /**
   * Base all terms with a relative IRI with the given base.
   * @param {Grapoi|Grapoi[]|Term|Term[]} base Base of the terms
   * @returns {Constructor} Instance with a single pointer with the term based
   */
  base(base) {
    if (!base) {
      throw new Error('base parameter is required')
    }

    base = this._toTerm(base)

    for (const ptr of this.ptrs) {
      baseDataset(base, { factory: this.factory })(ptr.dataset)
    }

    return this.node(baseTerm(base, { factory: this.factory })(this.term))
  }

  /**
   * Use the given score function on all pointers and return the pointer with the best score.
   * @param {function} score Score function
   * @returns {Constructor} Instance with a single pointer with the best score
   */
  best(score) {
    return this.score(score, { limit: 1 })
  }

  /**
   * Delete quad(s) with the current terms as the object.
   * @param {Grapoi|Grapoi[]|Term|Term[]} predicates Predicates of the quads
   * @param {Grapoi|Grapoi[]|Term|Term[]} [subjects] Subjects of the quads
   * @returns {Grapoi} this
   */
  deleteIn(predicates, subjects) {
    return super.deleteIn(this._toTermArray(predicates), this._toTermArray(subjects))
  }

  /**
   * Delete list(s).
   * @param {Grapoi|Grapoi[]|Term|Term[]} predicates Predicates of the lists
   * @returns {Grapoi} this
   */
  deleteList(predicates) {
    return super.deleteList(this._toTermArray(predicates))
  }

  /**
   * Delete quad(s) with the current terms as the subject.
   * @param {Grapoi|Grapoi[]|Term|Term[]} predicates Predicates of the quads
   * @param {Grapoi|Grapoi[]|Term|Term[]} [objects] Objects of the quads
   * @returns {Constructor} this
   */
  deleteOut(predicates, objects) {
    return super.deleteOut(this._toTermArray(predicates), this._toTermArray(objects))
  }

  /**
   * Filter the pointers based on matching quad(s) with the current terms as the object.
   * @param {Grapoi|Grapoi[]|Term|Term[]} predicates Predicates of the quads
   * @param {Grapoi|Grapoi[]|Term|Term[]} [subjects] Subjects of the quads
   * @returns {Constructor} Instance that contains only the filtered pointers
   */
  hasIn(predicates, subjects) {
    return super.hasIn(this._toTermArray(predicates), this._toTermArray(subjects))
  }

  /**
   * Filter the pointers based on matching quad(s) with the current terms as the subject.
   * @param {Grapoi|Grapoi[]|Term|Term[]} predicates Predicates of the quads
   * @param {Grapoi|Grapoi[]|Term|Term[]} [objects] Objects of the quads
   * @returns {Constructor} Instance that contains only the filtered pointers
   */
  hasOut(predicates, objects) {
    return super.hasOut(this._toTermArray(predicates), this._toTermArray(objects))
  }

  /**
   * Traverse the graph with the current terms as the object.
   * @param {Grapoi|Grapoi[]|Term|Term[]} predicates Predicates of the quads
   * @param {Grapoi|Grapoi[]|Term|Term[]} [subjects] Subjects of the quads
   * @returns {Constructor} Instance with pointers of the traversed target terms
   */
  in(predicates, subjects) {
    return super.in(this._toTermArray(predicates), this._toTermArray(subjects))
  }

  /**
   * Traverse the graph with the current terms as the subject.
   * @param {Grapoi|Grapoi[]|Term|Term[]} predicates Predicates of the quads
   * @param {Grapoi|Grapoi[]|Term|Term[]} [objects] Objects of the quads
   * @returns {Constructor} Instance with pointers of the traversed target terms
   */
  out(predicates, objects) {
    return super.out(this._toTermArray(predicates), this._toTermArray(objects))
  }

  /**
   * Jump to random terms.
   * @param {Grapoi|Grapoi[]|Term|Term[]} predicates Terms for the new pointers
   * @returns {Constructor} Instance with pointers of the selected terms
   */
  node(terms = null) {
    return super.node(this._toTermArray(terms))
  }

  /**
   * Rebase all terms of the current pointers with a new base.
   * @param {Grapoi|Grapoi[]|Term|Term[]} base New base of the terms
   * @returns {Constructor} Instance with a single pointer with the new base as the term
   */
  rebase(base) {
    if (!base) {
      throw new Error('base parameter is required')
    }

    base = this._toTerm(base)

    for (const ptr of this.ptrs) {
      rebaseDataset(ptr.term, base, { factory: this.factory })(ptr.dataset)
    }

    return this.node(base)
  }

  /**
   * Replace all terms of the current pointers with another term.
   * @param {Grapoi|Grapoi[]|Term|Term[]} replacement Term used as replacement
   * @returns {Constructor} Instance with a single pointer with the replacement as the term
   */
  replace(replacement) {
    if (!replacement) {
      throw new Error('replacement parameter is required')
    }

    replacement = this._toTerm(replacement)

    for (const ptr of this.ptrs) {
      replaceDataset(ptr.term, replacement, { factory: this.factory })(ptr.dataset)
    }

    return this.node(replacement)
  }

  /**
   * Score the pointers and sort them by score value.
   * @param {Function} score @rdfjs/score compatible score function
   * @param {Number} [limit] Limit for the result pointers
   * @param {Number} [offset] Offset for the result pointers
   * @returns {Constructor} Instance of the scored pointers, sorted and sliced.
   */
  score(score, { limit = Infinity, offset = 0 } = {}) {
    const ptrs = sortByScore(score(this))
      .slice(offset, offset + limit)
      .map(ptr => new Path({ ...ptr, factory: this.factory }))

    return this.clone({ ptrs })
  }
}

export default Grapoi
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.2</a> on Wed Mar 06 2024 15:33:48 GMT+0100 (Central European Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
